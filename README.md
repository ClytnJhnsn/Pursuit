Hey y'all.
At this point, the code doesn't actually RUN anything quite yet but all of our basic functionality is there. Entities exist in the environment and, at the moment, act according to the simplest forms of pursuit/evasion (direct pursuit/running directly away). We pretty much just need a Makefile and a better main (plus to fix the bugs I inevitably left in there) to make it actually run. Anyways, I'm just gonna run through the structure of the project real quick and make some points just I case I didn't wake up for the meeting (I'm so sorry if I didn't). 

If you look at main.cc, you'll see that all it does is makes Sim and updates in a bunch of times. Sim is the top level class in the project (represents the simulation). Sim has predator and prey as member variables, as well as some other parameters for specifications. At this point all Sim does is gets updated and check if the prey has been caught or not, while keeping track of the time elapsed. In the future, I imagine Sim keeping track of pretty much any statistics we need to keep track of and then taking care of writing that data to a file so we can visualize it. We can also write a program to run Sim many times and keep track of all the statistics so we can analyze on a larger scale. At every step (when Sim::Update is called), Sim calls Update() on it's entities. 
Both Predator and Prey inherit Entity for basic "entity in simulation" functionality. The Update() functions here are pretty self-explanatory. Look at what direction we're facing and move (speed) units in that direction. But first, we call Apply() on that entity's movement strategy, which informs the entitys movement by changing it's direction vector. This is where the code can be very easily extendible. To implement a pursuit/evasion strategy (or just generally any movement behavior), you just have to do the math on how that might change the entity's direction vector. (You can change speed too if you wanna get more complicated). 

The biggest discrepency between our two methods to choose from was that one was discrete and one continuous. The problem with continuous implementations is that the state-space graph gets literally infinitely big (because the environment is infinitely precise). We could potentially solve this by using ranges/approximations in our state space. So, each node on represents a range of values instead of 1. For instance, Node A represents Predator in some 1x1x1 cube in the environment. our decisions would be informed almost as if the environment were discrete, but we still get the entity behavior of a continuous world. Another way to go about this would be to subvert the entire "search a tree of states for a goal state" decision process. Just represent the whole decision process by some function that does some math and tells the entity what to do. There could be a lot of ways to do this and still have our agents be intelligent. For me, maybe the ideal scenario is a mix of both. Maybe, instead of searching for a goal state, the entity averages the heuristic values of the next 7 layers in each direction. Then we put that into some function that spits out the entity's behavior. Either way, I think having an intelligent agent in this type of environment is 100% doable. 

Implementing this decision process would probably look like making another class for the decision process and giving each entity a decision process as a member variable. This process can use the vectors that might be returned by whatever movement strategy options are available to the entity making the decision. I think this would be fairly simple to implement into the code, coming up with the algorithm would be the harder part.

This setup provides a good baseline for how we can simulate an environment with entites that chase/avoid each other. The biggest upside of this implementation is that expanding on what we have so far is super simple. Most new features would just require a new class somewhere (NewClass) and giving whatever object is using NewClass the ability to handle and use NewClass. 

Also I'm not yet sure how we should go about storing and plotting the data, but I think gnuplot is a really good option. Just would need to figure out how to store the data in a file so that gnuplot and plot it correctly.

I hope you guys like :)